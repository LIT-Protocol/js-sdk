---
title: 'Payment Manager Setup'
description: 'Configure payment system for the Lit JS SDK'
---

<Warning>
  ‚ùóÔ∏è Payment status by network:
  - **naga-dev** ‚Äì usage is currently free; no deposits required.
  - **naga-test** ‚Äì payments are enabled using test tokens (see faucet link
    below).
  - **Mainnet** ‚Äì coming soon; mainnet payment details will be announced
    shortly.
</Warning>

<Note>
  üí∞ Need Test Tokens? Visit the [Chronicle Yellowstone
  Faucet](https://chronicle-yellowstone-faucet.getlit.dev/) to get test tokens
  for your EOA account.
</Note>

<Tip>
  See the [Payment Manager Reference API](/sdk/sdk-reference/lit-client/functions/createLitClient#getpaymentmanager) for more details on how to manage payments.
</Tip>

## Overview

The Payment Manager handles Lit Protocol's payment system - a billing mechanism for decentralized cryptographic services. Users deposit funds to pay for compute resources when accessing core network operations:

- [Encryption/Decryption](/sdk/auth-context-consumption/encrypt-and-decrypt) - Encrypt data that only authorized users or conditions can decrypt.
- [PKP Signing](/sdk/auth-context-consumption/pkp-sign) - Generate signatures and sign transactions using your PKP wallet.
- [Lit Actions](/sdk/auth-context-consumption/execute-js) - Execute serverless JavaScript functions for decentralized computation.

Similar to how you pay AWS for cloud computing, this system ensures the decentralized network can sustain itself and compensate node operators. The Payment Manager allows you to deposit funds, request withdrawals (with security delays), and manage balances for yourself or delegate payment for other users - enabling applications to sponsor their users' costs for a seamless experience.

<Steps>
  <Step title="Payment Manager Setup">
  
  ```typescript Naga Test
  import { createLitClient } from '@lit-protocol/lit-client';
  import { nagaTest } from '@lit-protocol/networks';

  // 1. Create lit client
  const litClient = await createLitClient({ network: nagaTest });

// 2. Get PaymentManager instance (requires account for transactions)
const paymentManager = await litClient.getPaymentManager({
    account: yourAccount // viem account instance
});

````

  </Step>

  <Step title="Create an account">
<CodeGroup>

```typescript wagmi
// 1. import the useWalletClient function from wagmi
import { useWalletClient } from 'wagmi';

// 2. Use your connected wallet as the account
const { data: myAccount } = useWalletClient();
````

```typescript viem/accounts
// 1. import the privateKeyToAccount function from viem/accounts
import { privateKeyToAccount } from 'viem/accounts';

// 2. Convert your private key to a viem account object that can be used for payment operations.
const myAccount = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
```

</CodeGroup>
  </Step>

  <Step title="Deposit funds">
<CodeGroup>

```typescript Deposit funds to your own account
// 1. Deposit funds to your own account
const result = await paymentManager.deposit({
  amountInEth: '0.1',
});

console.log(`Deposit successful: ${result.hash}`);
// Returns: { hash: string, receipt: object }
```

```typescript Deposit for another user
// 1. Deposit funds for another user
const result = await paymentManager.depositForUser({
  userAddress: '0x742d35Cc6638Cb49f4E7c9ce71E02ef18C53E1d5',
  amountInEth: '0.05',
});

console.log(`Deposit successful: ${result.hash}`);
// Returns: { hash: string, receipt: object }
```

</CodeGroup>
  </Step>

</Steps>

## Payment Delegation / Sponsoring Your Users

<Steps>
  <Step title="Define spending limit">

  Define spending limits for the users you want to sponsor (values are in wei).

  <CodeGroup>

```typescript
await paymentManager.setRestriction({
  totalMaxPrice: '1000000000000000000', // 1 ETH equivalent limit
  requestsPerPeriod: '100', // max number of sponsored requests in a period
  periodSeconds: '3600', // rolling window (1 hour in this example)
});
```

  </CodeGroup>

  </Step>

  <Step title="Delegate users">

  With restrictions set, delegate one or more users to spend from your payer wallet.

  <CodeGroup>

```typescript
await paymentManager.delegatePaymentsBatch({
  userAddresses: ['0xAlice...', '0xBob...'],
});
```

  </CodeGroup>
  </Step>

  <Step title="(Optional) Inspect Balance">

  Optionally inspect Payer/Sponsor Ledger balance

    <CodeGroup>
    ```ts
  const balance = await paymentManager.getBalance({
      userAddress: viemAccount.address,
  });
    ```
    </CodeGroup>
  </Step>

  <Step title="Remove users (optional)">

  Undelegate users when you no longer want to sponsor them.

  <CodeGroup>

```typescript
await paymentManager.undelegatePaymentsBatch({
  userAddresses: ['0xAlice...'],
});
```

  </CodeGroup>

  </Step>
</Steps>

## **Alternatively**

Manage delegation via the hosted or self-hosted Auth Service (see [Auth Services setup](/sdk/getting-started/auth-services) for the full flow).

## After Payment Delegation

**Users decrypt as normal** ‚Äì we still call `litClient.decrypt` with an auth context; the network draws fees from the delegated payer instead of the user‚Äôs wallet.

<Note>
  ‚ÑπÔ∏è `userMaxPrice` is recommended for sponsored sessions, typically the same value or less than the the restriction the sponsor set; optional guardrail when self-funded.
</Note>

```typescript highlight={18}
// Client-side decrypt with sponsored payments
const authContext = await authManager.createEoaAuthContext({
  litClient,
  config: { account: walletClient },
  authConfig: {
    resources: [
      ['access-control-condition-decryption', '*'],
      ['lit-action-execution', '*'],
    ],
  },
});

const response = await litClient.decrypt({
  data: encryptedData,
  unifiedAccessControlConditions: accs,
  authContext,
  chain: 'ethereum',
  userMaxPrice: 1000000000000000000n,
});
```

## Auth Service API Endpoints

Leverage the hosted Auth Service to manage delegation without exposing private keys in your application. Full request/response details live in the [Auth Services setup guide](/sdk/getting-started/auth-services#payment-delegation-apis). In practice you will:

- Call `authService.registerPayer` (hosted or self-hosted) to derive a payer wallet + `payerSecretKey`.
- Call `authService.delegateUsers` (`/add-users`) to sponsor a list of user addresses.
- Or skip the service entirely and use the Payment Manager methods directly (example below).

```typescript
import { createLitClient } from '@lit-protocol/lit-client';
import { nagaTest } from '@lit-protocol/networks';

// 1. Create the Lit client for the naga-test environment
const litClient = await createLitClient({ network: nagaTest });

const authServiceBaseUrl = 'https://naga-test-auth-service.getlit.dev/';
const apiKey = process.env.YOUR_AUTH_SERVICE_API_KEY!;

// 3. Register a payer wallet (store the secret securely server-side)
const registerResponse = await litClient.authService.registerPayer({
  authServiceBaseUrl,
  apiKey,
});

console.log('Payer wallet:', registerResponse.payerWalletAddress);
console.log('Payer secret (store securely!):', registerResponse.payerSecretKey);

// 4. Later on, delegate payments for multiple users using the saved secret
const delegateResponse = await litClient.authService.delegateUsers({
  authServiceBaseUrl,
  apiKey,
  payerSecretKey: registerResponse.payerSecretKey,
  userAddresses: [
    '0x1234...abcd',
    '0xabcd...1234',
  ],
});

console.log('Delegation submitted with tx hash:', delegateResponse.txHash);

// 5. Continue to use the same payer secret for future delegation calls
```

### How the Auth Service derives payer wallets

- For hosted or self-hosted deployments, see the derivation and rotation notes in the [Auth Services guide](/sdk/getting-started/auth-services#payment-delegation-apis). Manual deployments can always provision and delegate entirely via the `PaymentManager` helper without touching these endpoints.
