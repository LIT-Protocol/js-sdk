---
title: 'Payment Manager Setup'
description: 'Configure payment system for the Lit JS SDK'
---

<Warning>
  ‚ùóÔ∏è Currently free on the dev network, so no need to deposit funds. More
  details coming soon for test and production networks.
</Warning>

<Note>
  üí∞ Need Test Tokens? Visit the [Chronicle Yellowstone
  Faucet](https://chronicle-yellowstone-faucet.getlit.dev/) to get test tokens
  for your EOA account.
</Note>

<Tip>
  See SDK Reference for more details on the Payment Manager. [Payment Manager
  Reference](/sdk/sdk-reference/lit-client/functions/createLitClient#getpaymentmanager)
</Tip>

## Overview

The Payment Manager demonstrates Lit Protocol's payment system - a billing system for decentralised cryptographic services. Users pay for compute resources on the Lit network to access core services like:

- Encryption/Decryption - Secure data with programmable access control
- PKP Signing - Cryptographic keys that can sign transactions based on conditions
- Lit Actions - Serverless functions with cryptographic capabilities
  Similar to how you pay AWS for cloud computing, this\system ensures the decentralised network can sustain itself and pay node operators. You can deposit funds, request withdrawals with security delays, and manage balances for yourself or other users (enabling applications to sponsor their users' costs for better UX).

<Steps>
  <Step title="Payment Manager Setup">
  
```typescript
import { createLitClient } from '@lit-protocol/lit-client';
import { nagaTest } from '@lit-protocol/networks';

// 1. Create lit client
const litClient = await createLitClient({ network: nagaTest });

// 2. Get PaymentManager instance (requires account for transactions)
const paymentManager = await litClient.getPaymentManager({
account: yourAccount // viem account instance
});

````

  </Step>

  <Step title="Create an account">
<CodeGroup>

```typescript wagmi
// 1. import the useWalletClient function from wagmi
import { useWalletClient } from 'wagmi';

// 2. Use your connected wallet as the account
const { data: myAccount } = useWalletClient();
````

```typescript viem/accounts
// 1. import the privateKeyToAccount function from viem/accounts
import { privateKeyToAccount } from 'viem/accounts';

// 2. Convert your private key to a viem account object that can be used for payment operations.
const myAccount = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
```

</CodeGroup>
  </Step>

  <Step title="Deposit funds">
<CodeGroup>

```typescript Deposit funds to your own account
// 1. Deposit funds to your own account
const result = await paymentManager.deposit({
  amountInEth: '0.1',
});

console.log(`Deposit successful: ${result.hash}`);
// Returns: { hash: string, receipt: object }
```

```typescript Deposit for another user
// 1. Deposit funds for another user
const result = await paymentManager.depositForUser({
  userAddress: '0x742d35Cc6638Cb49f4E7c9ce71E02ef18C53E1d5',
  amountInEth: '0.05',
});

console.log(`Deposit successful: ${result.hash}`);
// Returns: { hash: string, receipt: object }
```

</CodeGroup>
  </Step>

</Steps>

## Sponsoring Your Users (Capacity Delegation Replacement)

If your app previously minted Capacity Credits and handed users a `CapacityDelegationAuthSig`, the equivalent Naga flow is:

1. **Fund a payer wallet** ‚Äì call `litClient.getPaymentManager({ account })` and deposit $LITKEY ($tstLPX in testnet) into the ledger contract (see examples above).
2. **Register the payer** ‚Äì decide how you want to provision and operate the sponsor wallet:
   - **Lit-hosted Auth Service** ‚Äì call `authService.registerPayer`; Lit derives the wallet + `payerSecretKey` for you (ideal for prototypes).
   - **Self-hosted Auth Service** ‚Äì deploy the open-source service (see [Auth Services setup](/sdk/getting-started/auth-services)) so derivation stays within your infrastructure. You‚Äôll supply your own `LIT_DELEGATION_ROOT_MNEMONIC`.
   - **Manual (no Auth Service)** ‚Äì generate a wallet yourself (e.g. `privateKeyToAccount`) and store the private key securely; you‚Äôll call the Payment Manager directly in the next step.
3. **Delegate end-user addresses** ‚Äì map users to the payer:
   - Using an Auth Service: POST to `authService.add-users`.
   - Manual route: call `paymentManager.delegatePayments` (for a single user) or `paymentManager.delegatePaymentsBatch` (for multiple users) with your server-side account; this writes to the same Payment Delegation contract.

<Note>
  For production environments we recommend running your own Auth Service (self-hosted) so you retain full custody over the `LIT_DELEGATION_ROOT_MNEMONIC` and derivation secrets. The Lit-hosted Auth Service is handy for prototypes and quick starts, but you still remain responsible for storing the returned `payerSecretKey` securely.
</Note>
4. **Users decrypt as normal** ‚Äì the browser still calls `litClient.decrypt` with an auth context; the network draws fees from the delegated payer instead of the user‚Äôs wallet.

```typescript server
// Manual delegation without Auth Service
import { createLitClient } from '@lit-protocol/lit-client';
import { privateKeyToAccount } from 'viem/accounts';
import { nagaTest } from '@lit-protocol/networks';

const payerAccount = privateKeyToAccount(
  process.env.PAYER_PRIVATE_KEY as `0x${string}`
);
const litClient = await createLitClient({ network: nagaTest });

const paymentManager = await litClient.getPaymentManager({
  account: payerAccount,
});

// Delegate a single user
await paymentManager.delegatePayments({ userAddress: '0xUser...' });

// Or delegate multiple users in one transaction
await paymentManager.delegatePaymentsBatch({
  userAddresses: ['0xAlice...', '0xBob...'],
});
```

```typescript
// Client-side decrypt with sponsored payments
const authContext = await authManager.createEoaAuthContext({
  litClient,
  config: { account: walletClient },
  authConfig: {
    resources: [
      ['access-control-condition-decryption', '*'],
      ['lit-action-execution', '*'],
    ],
  },
});

const response = await litClient.decrypt({
  data: encryptedData,
  unifiedAccessControlConditions: accs,
  authContext,
  chain: 'ethereum',
  userMaxPrice: BigInt('200000000000000000'), // optional guardrail
});
```

Behind the scenes the SDK:

- Builds a pricing context during handshake (product, per-node prices, threshold).
- Encrypts requests per node using the JIT keyset.
- Emits per-node max price in the session signature.
- Lets the validators call `Ledger.chargeUser` against the delegated payer wallet.

## Auth Service API Endpoints

Leverage the hosted Auth Service to manage delegation without exposing private keys in your application. Full request/response details live in the [Auth Services setup guide](/sdk/getting-started/auth-services#payment-delegation-apis). In practice you will:

- Call `authService.registerPayer` (hosted or self-hosted) to derive a payer wallet + `payerSecretKey`.
- Call `authService.delegateUsers` (`/add-users`) to sponsor a list of user addresses.
- Or skip the service entirely and use the Payment Manager methods directly (example below).

> The legacy capacity-credit minting flow has been removed. Payment delegation now interacts directly with the Payment Manager contracts.

```typescript
import { createLitClient } from '@lit-protocol/lit-client';
import { nagaTest } from '@lit-protocol/networks';

// 1. Create the Lit client for the naga-test environment
const litClient = await createLitClient({ network: nagaTest });

const authServiceBaseUrl = 'https://naga-test-auth-service.example.com';
const apiKey = process.env.LIT_API_KEY!;

// 3. Register a payer wallet (store the secret securely server-side)
const registerResponse = await litClient.authService.registerPayer({
  authServiceBaseUrl,
  apiKey,
});

console.log('Payer wallet:', registerResponse.payerWalletAddress);
console.log('Payer secret (store securely!):', registerResponse.payerSecretKey);

// 4. Later on, delegate payments for multiple users using the saved secret
const delegateResponse = await litClient.authService.delegateUsers({
  authServiceBaseUrl,
  apiKey,
  payerSecretKey: registerResponse.payerSecretKey,
  userAddresses: ['0x1234...abcd', '0xabcd...1234'],
});

console.log('Delegation submitted with tx hash:', delegateResponse.txHash);

// 5. Continue to use the same payer secret for future delegation calls
```

### How the Auth Service derives payer wallets

- For hosted or self-hosted deployments, see the derivation and rotation notes in the [Auth Services guide](/sdk/getting-started/auth-services#payment-delegation-apis). Manual deployments can always provision and delegate entirely via the `PaymentManager` helper without touching these endpoints.

![](https://www.plantuml.com/plantuml/png/XPAn3jCm48PtFyMfKw8IiKSAQcab1a1K58c1CXpEaLWaJcHVIlFs6DkKcBHYYy-Vl_Floyuo6fxwJh3YZc0_SGjdCbSb2KuuzwGPZjHHWwm6BSJeS2NLYAw-ENJAxMy0BOJFT7ifyz3lGbodv3l5qG3lKMD3nlFn-ndh6RTyr3lSFTN5MYo96Xc_eINOh8F2OT1iKFeUzuKGLGKVgL6MoS28CnceAX5lNhnQ1YpXzE7y2LwQY1SUl-ZiLk2eYXyqvsA1hqw_8Kq6cKARCqb3VD57CkfAy1ExZXY-cw67NbC_Q2LX2quCJfnwdJXSi0ogp_xilguDMNlH2_rRcdt2-0m4aoLZ_viGwxhmv3BSYz2iiDuSAXxwydMLEmwaX8RYBBDSnABR_plY4fmCcToZEbUgMM1Ub0uxGoc7INCk0XNJf509Ibj6pGfvPVyNhUCZnRfzZIpRp4VCHGgxu_TVo1zSlAxuim75WoPy0qEIrCWhPJeBZxPeswUpjvEKP2rix-IET3trtIy0)
