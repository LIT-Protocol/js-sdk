---
title: 'Payment Manager Setup'
description: 'Configure payment system for the Lit JS SDK'
---

<Warning>
  ‚ùóÔ∏è Payment status by network:
  - **naga-dev** ‚Äì usage is currently free; no deposits required.
  - **naga-test** ‚Äì payments are enabled using test tokens (see faucet link
    below).
  - **Mainnet** ‚Äì coming soon; mainnet payment details will be announced
    shortly.
</Warning>

<Note>
  üí∞ Need Test Tokens? Visit the [Chronicle Yellowstone
  Faucet](https://chronicle-yellowstone-faucet.getlit.dev/) to get test tokens
  for your EOA account.
</Note>

<Tip>
  See SDK Reference for more details on the Payment Manager. [Payment Manager
  Reference](/sdk/sdk-reference/lit-client/functions/createLitClient#getpaymentmanager)
</Tip>

## Overview

The Payment Manager demonstrates Lit Protocol's payment system - a billing system for decentralised cryptographic services. Users pay for compute resources on the Lit network to access core services like:

- [Encryption/Decryption](/sdk/auth-context-consumption/encrypt-and-decrypt) - Secure data with programmable access control.
- [PKP Signing](/sdk/auth-context-consumption/pkp-sign) - Cryptographic keys that can sign transactions based on conditions.
- [Lit Actions](/sdk/auth-context-consumption/execute-js) - Serverless functions with cryptographic capabilities.

Similar to how you pay AWS for cloud computing, this system ensures the decentralised network can sustain itself and pay node operators. Each payer keeps a balance in the on-chain Lit Ledger contract funded with `$LITKEY` (or `$tstLPX` on testnet), which the network debits as requests execute. You can deposit funds, request withdrawals with security delays, and manage balances for yourself or other users (enabling applications to sponsor their users' costs for better UX).

<Steps>
  <Step title="Payment Manager Setup">
  
```typescript
import { createLitClient } from '@lit-protocol/lit-client';
import { nagaTest } from '@lit-protocol/networks';

// 1. Create lit client
const litClient = await createLitClient({ network: nagaTest });

// 2. Get PaymentManager instance (requires account for transactions)
const paymentManager = await litClient.getPaymentManager({
  account: yourAccount // viem account instance
});

````

  </Step>

  <Step title="Create an account">
<CodeGroup>

```typescript wagmi
// 1. import the useWalletClient function from wagmi
import { useWalletClient } from 'wagmi';

// 2. Use your connected wallet as the account
const { data: myAccount } = useWalletClient();
````

```typescript viem/accounts
// 1. import the privateKeyToAccount function from viem/accounts
import { privateKeyToAccount } from 'viem/accounts';

// 2. Convert your private key to a viem account object that can be used for payment operations.
const myAccount = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
```

</CodeGroup>
  </Step>

  <Step title="Deposit funds">
<CodeGroup>

```typescript Deposit funds to your own account
// 1. Deposit funds to your own account
const result = await paymentManager.deposit({
  amountInEth: '0.1',
});

console.log(`Deposit successful: ${result.hash}`);
// Returns: { hash: string, receipt: object }
```

```typescript Deposit for another user
// 1. Deposit funds for another user
const result = await paymentManager.depositForUser({
  userAddress: '0x742d35Cc6638Cb49f4E7c9ce71E02ef18C53E1d5',
  amountInEth: '0.05',
});

console.log(`Deposit successful: ${result.hash}`);
// Returns: { hash: string, receipt: object }
```

</CodeGroup>
  </Step>

</Steps>

## Sponsoring Your Users

<Steps>
  <Step title="Define spending limit">

  Define spending limits for the users you want to sponsor (values are in wei).

  <CodeGroup>

```typescript
await paymentManager.setRestriction({
  totalMaxPrice: '1000000000000000000', // 1 ETH equivalent limit
  requestsPerPeriod: '100', // max number of sponsored requests in a period
  periodSeconds: '3600', // rolling window (1 hour in this example)
});
```

  </CodeGroup>

  </Step>

  <Step title="Delegate users">

  With restrictions set, delegate one or more users to spend from your payer wallet.

  <CodeGroup>

```typescript
await paymentManager.delegatePaymentsBatch({
  userAddresses: ['0xAlice...', '0xBob...'],
});
```

  </CodeGroup>

  </Step>

  <Step title="Remove users (optional)">

  Undelegate users when you no longer want to sponsor them.

  <CodeGroup>

```typescript
await paymentManager.undelegatePaymentsBatch({
  userAddresses: ['0xAlice...'],
});
```

  </CodeGroup>

  </Step>
</Steps>

## **Alternatively**

Manage delegation via the hosted or self-hosted Auth Service (see [Auth Services setup](/sdk/getting-started/auth-services) for the full flow).

## After Payment Delegation

**Users decrypt as normal** ‚Äì we still call `litClient.decrypt` with an auth context; the network draws fees from the delegated payer instead of the user‚Äôs wallet.

<Note>
  ‚ÑπÔ∏è `userMaxPrice` is recommended for sponsored sessions, typically the same value or less than the the restriction the sponsor set; optional guardrail when self-funded.
</Note>

```typescript highlight={18}
// Client-side decrypt with sponsored payments
const authContext = await authManager.createEoaAuthContext({
  litClient,
  config: { account: walletClient },
  authConfig: {
    resources: [
      ['access-control-condition-decryption', '*'],
      ['lit-action-execution', '*'],
    ],
  },
});

const response = await litClient.decrypt({
  data: encryptedData,
  unifiedAccessControlConditions: accs,
  authContext,
  chain: 'ethereum',
  userMaxPrice: 1000000000000000000n,
});
```

## Auth Service API Endpoints

Leverage the hosted Auth Service to manage delegation without exposing private keys in your application. Full request/response details live in the [Auth Services setup guide](/sdk/getting-started/auth-services#payment-delegation-apis). In practice you will:

- Call `authService.registerPayer` (hosted or self-hosted) to derive a payer wallet + `payerSecretKey`.
- Call `authService.delegateUsers` (`/add-users`) to sponsor a list of user addresses.
- Or skip the service entirely and use the Payment Manager methods directly (example below).

```typescript
import { createLitClient } from '@lit-protocol/lit-client';
import { nagaTest } from '@lit-protocol/networks';

// 1. Create the Lit client for the naga-test environment
const litClient = await createLitClient({ network: nagaTest });

const authServiceBaseUrl = 'https://naga-test-auth-service.getlit.dev/';
const apiKey = process.env.YOUR_AUTH_SERVICE_API_KEY!;

// 3. Register a payer wallet (store the secret securely server-side)
const registerResponse = await litClient.authService.registerPayer({
  authServiceBaseUrl,
  apiKey,
});

console.log('Payer wallet:', registerResponse.payerWalletAddress);
console.log('Payer secret (store securely!):', registerResponse.payerSecretKey);

// 4. Later on, delegate payments for multiple users using the saved secret
const delegateResponse = await litClient.authService.delegateUsers({
  authServiceBaseUrl,
  apiKey,
  payerSecretKey: registerResponse.payerSecretKey,
  userAddresses: ['0x1234...abcd', '0xabcd...1234'],
});

console.log('Delegation submitted with tx hash:', delegateResponse.txHash);

// 5. Continue to use the same payer secret for future delegation calls
```

### How the Auth Service derives payer wallets

- For hosted or self-hosted deployments, see the derivation and rotation notes in the [Auth Services guide](/sdk/getting-started/auth-services#payment-delegation-apis). Manual deployments can always provision and delegate entirely via the `PaymentManager` helper without touching these endpoints.
