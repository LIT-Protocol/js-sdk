import path from 'path';
import { success, fail, testThis } from '../../tools/scripts/utils.mjs';
import { client } from '../00-setup.mjs';
import { LitAbility, LitActionResource } from '@lit-protocol/auth-helpers';
import { ethers } from 'ethers';
import { PKPEthersWallet } from '@lit-protocol/pkp-ethers';
import LITCONFIG from '../../lit.config.json' assert { type: 'json' };

// NOTE: you need to hash data before you send it in.
// If you send something that isn't 32 bytes, the nodes will return an error.
// We can also simply use crypto.subtile like this:
// const TO_SIGN = new Uint8Array(
//   await crypto.subtle.digest('SHA-256', new TextEncoder().encode('meow'))
// );
const TO_SIGN = ethers.utils.arrayify(ethers.utils.keccak256([1, 2, 3, 4, 5]));

export async function main() {
  // ==================== Setup ====================
  const authNeededCallback = async (params) => {
    const response = await client.signSessionKey({
      statement: params.statement,
      authMethods: [
        {
          authMethodType: 1,
          accessToken: JSON.stringify(globalThis.LitCI.CONTROLLER_AUTHSIG),
        },
      ],
      pkpPublicKey: `0x${globalThis.LitCI.AUTH_METHOD_PKP_INFO.publicKey}`,
      expiration: params.expiration,
      resources: params.resources,
      chainId: 1,
    });
    return response.authSig;
  };

  const resourceAbilities = [
    {
      resource: new LitActionResource('*'),
      ability: LitAbility.PKPSigning,
    },
  ];

  // ==================== Test Logic ====================
  const pkpWallet = new PKPEthersWallet({
    pkpPubKey: globalThis.LitCI.AUTH_METHOD_PKP_INFO.publicKey,
    rpc: LITCONFIG.CHRONICLE_RPC,
    litNetwork: globalThis.LitCI.network,
    authContext: {
      client: client,
      getSessionSigsProps: {
        chain: 'ethereum',
        resourceAbilityRequests: resourceAbilities,
        authNeededCallback,
      },
    },
  });

  await pkpWallet.init();

  const signature = await pkpWallet.signMessage(TO_SIGN);

  // ==================== Post-Validation ====================
  // check if the given signature is a valid signature using ethers
  const isValid = ethers.utils.verifyMessage(
    TO_SIGN,
    signature,
    pkpWallet.address
  );

  if (!isValid) {
    return fail(
      `it should use sessionSigs generated by eth wallet auth method to sign data. Signature is ${signature} and pkpWallet.address is ${pkpWallet.address}`
    );
  }

  // ==================== Success ====================
  return success(
    `it should use sessionSigs generated by eth wallet auth method to sign data. Signature is ${signature} and pkpWallet.address is ${pkpWallet.address} and isValid is ${isValid}`
  );
}
await testThis({ name: path.basename(import.meta.url), fn: main });
