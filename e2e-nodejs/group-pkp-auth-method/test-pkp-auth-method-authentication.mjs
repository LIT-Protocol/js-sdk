import path from 'path';
import { success, fail, testThis } from '../../tools/scripts/utils.mjs';
import LITCONFIG from '../../lit.config.json' assert { type: 'json' };
import { client } from '../00-setup.mjs';
import { LitAbility, LitActionResource } from '@lit-protocol/auth-helpers';
import { LitAuthClient } from '@lit-protocol/lit-auth-client';
import { AuthMethodType, ProviderType } from '@lit-protocol/constants';
import { ethers } from 'ethers';
import { PKPEthersWallet } from '@lit-protocol/pkp-ethers';

// NOTE: you need to hash data before you send it in.
// If you send something that isn't 32 bytes, the nodes will return an error.
const TO_SIGN = new Uint8Array(
  await crypto.subtle.digest('SHA-256', new TextEncoder().encode('meow'))
);

export async function main() {
  // ==================== Setup ====================

  const authMethod = {
    authMethodType: AuthMethodType.EthWallet,
    accessToken: JSON.stringify(globalThis.LitCI.CONTROLLER_AUTHSIG),
  };

  const pkpSignRes = await client?.executeJs({
    authSig: globalThis.LitCI.CONTROLLER_AUTHSIG,
    authMethods: [authMethod],
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign,
          publicKey,
          sigName: "sig",
        });
        LitActions.setResponse({response: JSON.stringify(Lit.Auth)});
      })();`,
    jsParams: {
      toSign: TO_SIGN,
      publicKey: globalThis.LitCI.PKP_INFO.publicKey,
    },
  });

  // ==================== Post-Validation ====================

  if (!pkpSignRes) {
    return fail(
      'Failed to sign data with sessionSigs generated by eth wallet auth method'
    );
  }

  let missingKeys = [];

  if (pkpSignRes) {
    ['r', 's', 'recid', 'signature', 'publicKey', 'dataSigned'].forEach(
      (key) => {
        if (pkpSignRes.signatures['sig'][key] === undefined) {
          missingKeys.push(key);
        }
      }
    );
  }

  if (missingKeys.length > 0) {
    return fail(`Missing keys: ${missingKeys.join(', ')}`);
  }

  if (
    !pkpSignRes.response.authSigAddress ==
    LITCONFIG.CONTROLLER_AUTHSIG_2.address
  ) {
    return fail(`Missing or non matching auth sig address in Lit.Auth context`);
  }

  if (pkpSignRes.response.authMethodContexts.length < 1) {
    return fail('not enough authentication material in Lit.Auth context');
  }

  // ==================== Success ====================
  return success(
    `it should use sessionSigs generated by eth wallet auth method to sign data. Signature is ${
      pkpSignRes.signatures
    } and pkpSignRes is ${JSON.stringify(pkpSignRes)}`
  );
}

await testThis({ name: path.basename(import.meta.url), fn: main });
