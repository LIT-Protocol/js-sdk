import fs from 'fs';
import * as pako from 'pako';

const WASM_MODULE_PATH = 'rust/pkg/wasm-internal_bg.wasm';
const WASM_BINDING_PATH = 'rust/pkg/wasm-internal.js';
const CHUNK_SIZE = 100;
const COMMENT_OUT_LINES = [
  // This regex matches the block that checks if `module_or_path` is undefined and assigns a URL to it.
  /if\s*\(\s*typeof\s+module_or_path\s*===\s*['"`]undefined['"`]\s*\)\s*{\s*module_or_path\s*=\s*new\s+URL\s*\(\s*['"`]wasm-internal_bg\.wasm['"`],\s*import\.meta\.url\s*\);\s*}/g,

  // This regex matches the block that checks if `module_or_path` is a string, `Request`, or `URL` and assigns it to the result of a `fetch`.
  /if\s*\(\s*typeof\s+module_or_path\s*===\s*['"`]string['"`]\s*\|\|\s*\(typeof\s+Request\s*===\s*['"`]function['"`]\s*&&\s*module_or_path\s*instanceof\s+Request\)\s*\|\|\s*\(typeof\s+URL\s*===\s*['"`]function['"`]\s*&&\s*module_or_path\s*instanceof\s+URL\)\s*\)\s*{\s*module_or_path\s*=\s*fetch\s*\(module_or_path\);\s*}/g,
];

function main() {
  const wasmModule = fs.readFileSync(WASM_MODULE_PATH);
  const wasmBindingModule = fs.readFileSync(WASM_BINDING_PATH);

  let wasmModuleBuffer = Buffer.from(wasmModule);
  wasmModuleBuffer = pako.deflate(new Uint8Array(wasmModuleBuffer));
  const wasmModuleB64 = Buffer.from(wasmModuleBuffer).toString('base64');
  let buffer = `let moduleBuffer = "";`;
  for (let i = 0; i < wasmModuleB64.length; i += CHUNK_SIZE) {
    const chunk = wasmModuleB64.slice(i, i + CHUNK_SIZE);
    buffer += `\nmoduleBuffer += "${chunk}";`;
  }

  let bindingModuleString = `
// @ts-nocheck - autogenerated from copyWasmBinary.mjs
import * as pako from 'pako';
  `;
  bindingModuleString += '\n';
  bindingModuleString += buffer;
  bindingModuleString += '\n';
  bindingModuleString += `
export function getModule() {
  let module = pako.inflate(new Uint8Array(Buffer.from(moduleBuffer, 'base64')));
  return Uint8Array.from(module);
}
`;

  bindingModuleString += wasmBindingModule;

  let allReplacementsDone = true; // Track whether all replacements were successful

  for (const commentOutItem of COMMENT_OUT_LINES) {
    const originalString = bindingModuleString; // Store the original string before replacement

    bindingModuleString = bindingModuleString.replace(
      commentOutItem,
      (match) => {
        const headerComment =
          '// NOTE: This line is commented out automatically by copyWasmBinary.mjs\n';
        const commentedBlock = match
          .split('\n') // Split the matched block into lines
          .map((line) => `// ${line}`) // Add "//" to each line
          .join('\n'); // Re-join the lines into a single string

        return `${headerComment}${commentedBlock}`; // Prepend the header comment to the commented block
      }
    );

    // If no replacement was done (i.e., original string remains the same), mark as failure
    if (originalString === bindingModuleString) {
      allReplacementsDone = false;
    }
  }

  // throw an error if all replacements were NOT successful
  if (!allReplacementsDone) {
    throw new Error(
      '❗️❗️ Failed to comment out all specified lines in the wasm binding module.'
    );
  } else {
    console.log('✅ All replacements were successful!');
  }

  console.log('Writing wasm module');
  fs.writeFileSync(WASM_BINDING_PATH, bindingModuleString);
}

main();
