const fs = require('fs');
const path = require('path');

const esbuild = require('esbuild');

const ensureDirectoryExistence = (filePath) => {
  const dirname = path.dirname(filePath);
  if (!fs.existsSync(dirname)) {
    fs.mkdirSync(dirname, { recursive: true });
  }
};

const wrapIIFEInStringPlugin = {
  name: 'wrap-iife-in-string',
  setup(build) {
    // Ensure write is set to false so our plugin will always receive outputFiles
    build.initialOptions.write = false;

    build.onEnd((result) => {
      if (result.errors.length > 0) {
        console.error('Build failed with errors:', result.errors);
        return;
      }

      result.outputFiles.forEach((outputFile) => {
        let content = outputFile.text;

        // Strip any Buffer shim imports that esbuild may have injected
        const bufferImportRegex =
          /^import\s+\{\s*Buffer\s*\}\s+from\s+['"]node:buffer['"];\s*globalThis\.Buffer\s*=\s*globalThis\.Buffer\s*\|\|\s*Buffer;\s*/m;
        content = content.replace(bufferImportRegex, '');

        // Use JSON.stringify to safely encode the content
        const wrappedContent = `/**
 * DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD. RUN \`pnpm generate-lit-actions\` IN THE ROOT DIRECTORY TO UPDATE THIS FILE.
 * @type {string}
 */
const code = ${JSON.stringify(content)};
module.exports = {
  code,
};
`;

        // Ensure the output directory exists
        const outputPath = path.resolve(outputFile.path);
        ensureDirectoryExistence(outputPath);

        // Write the modified content back to the output file
        fs.writeFileSync(outputPath, wrappedContent);
      });
    });
  },
};

(async () => {
  try {
    await esbuild
      .build({
        entryPoints: [
          './src/lib/self-executing-actions/ethereum/signTransactionWithEncryptedEthereumKey.ts',
          './src/lib/self-executing-actions/ethereum/signMessageWithEncryptedEthereumKey.ts',
          './src/lib/self-executing-actions/ethereum/generateEncryptedEthereumPrivateKey.ts',
          './src/lib/self-executing-actions/solana/signTransactionWithEncryptedSolanaKey.ts',
          './src/lib/self-executing-actions/solana/signMessageWithEncryptedSolanaKey.ts',
          './src/lib/self-executing-actions/solana/generateEncryptedSolanaPrivateKey.ts',
          './src/lib/self-executing-actions/common/exportPrivateKey.ts',
          './src/lib/self-executing-actions/common/batchGenerateEncryptedKeys.ts',
        ],
        bundle: true,
        minify: true,
        sourcemap: false,
        treeShaking: true,
        outdir: './src/generated/',
        inject: ['./buffer.shim.js'],
        external: ['ethers'],
        plugins: [wrapIIFEInStringPlugin],
        platform: 'browser',
      })
      .then((result) => {
        // Simple ANSI color helpers
        const color = {
          reset: '\x1b[0m',
          bold: '\x1b[1m',
          green: '\x1b[32m',
          cyan: '\x1b[36m',
          gray: '\x1b[90m',
          dim: '\x1b[2m',
        };

        console.log(
          `\n${color.bold}${color.cyan}üì¶ Built Lit Actions:${color.reset}\n`
        );

        const rows = result.outputFiles.map((file) => {
          const fileName = file.path.split('/').pop() ?? file.path;
          const bytes = file.text.length;
          const mbDecimal = (bytes / 1_000_000).toFixed(4);
          const mbBinary = (bytes / (1024 * 1024)).toFixed(4);
          return { fileName, mbDecimal, mbBinary };
        });

        const namePad = Math.max(...rows.map((r) => r.fileName.length)) + 2;

        for (const { fileName, mbDecimal, mbBinary } of rows) {
          console.log(
            `${color.green}‚úî${color.reset} ${fileName.padEnd(namePad)} ${
              color.gray
            }${mbDecimal} MB${color.reset} ${color.dim}(${mbBinary} MB binary)${
              color.reset
            }`
          );
        }

        console.log(
          `\n${color.bold}${color.green}‚úÖ Lit Actions built successfully!${color.reset}\n`
        );
      });
  } catch (e) {
    console.error('‚ùå Error building lit actions: ', e);
    process.exit(1);
  }
})();
