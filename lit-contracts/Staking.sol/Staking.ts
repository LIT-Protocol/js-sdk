/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from './common';

export declare namespace IDiamond {
  export type FacetCutStruct = {
    facetAddress: string;
    action: BigNumberish;
    functionSelectors: BytesLike[];
  };

  export type FacetCutStructOutput = [string, number, string[]] & {
    facetAddress: string;
    action: number;
    functionSelectors: string[];
  };
}

export declare namespace IDiamondLoupe {
  export type FacetStruct = {
    facetAddress: string;
    functionSelectors: BytesLike[];
  };

  export type FacetStructOutput = [string, string[]] & {
    facetAddress: string;
    functionSelectors: string[];
  };
}

export declare namespace LibStakingStorage {
  export type VersionStruct = {
    major: BigNumberish;
    minor: BigNumberish;
    patch: BigNumberish;
  };

  export type VersionStructOutput = [BigNumber, BigNumber, BigNumber] & {
    major: BigNumber;
    minor: BigNumber;
    patch: BigNumber;
  };

  export type ConfigStruct = {
    tokenRewardPerTokenPerEpoch: BigNumberish;
    complaintTolerance: BigNumberish;
    complaintIntervalSecs: BigNumberish;
    keyTypes: BigNumberish[];
    minimumValidatorCount: BigNumberish;
  };

  export type ConfigStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[],
    BigNumber
  ] & {
    tokenRewardPerTokenPerEpoch: BigNumber;
    complaintTolerance: BigNumber;
    complaintIntervalSecs: BigNumber;
    keyTypes: BigNumber[];
    minimumValidatorCount: BigNumber;
  };

  export type EpochStruct = {
    epochLength: BigNumberish;
    number: BigNumberish;
    endTime: BigNumberish;
    retries: BigNumberish;
    timeout: BigNumberish;
  };

  export type EpochStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    epochLength: BigNumber;
    number: BigNumber;
    endTime: BigNumber;
    retries: BigNumber;
    timeout: BigNumber;
  };

  export type ValidatorStruct = {
    ip: BigNumberish;
    ipv6: BigNumberish;
    port: BigNumberish;
    nodeAddress: string;
    reward: BigNumberish;
    senderPubKey: BigNumberish;
    receiverPubKey: BigNumberish;
  };

  export type ValidatorStructOutput = [
    number,
    BigNumber,
    number,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    ip: number;
    ipv6: BigNumber;
    port: number;
    nodeAddress: string;
    reward: BigNumber;
    senderPubKey: BigNumber;
    receiverPubKey: BigNumber;
  };
}

export interface StakingInterface extends utils.Interface {
  functions: {
    'diamondCut((address,uint8,bytes4[])[],address,bytes)': FunctionFragment;
    'facetAddress(bytes4)': FunctionFragment;
    'facetAddresses()': FunctionFragment;
    'facetFunctionSelectors(address)': FunctionFragment;
    'facets()': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'owner()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'adminKickValidatorInNextEpoch(address)': FunctionFragment;
    'adminRejoinValidator(address)': FunctionFragment;
    'adminSlashValidator(address,uint256)': FunctionFragment;
    'advanceEpoch()': FunctionFragment;
    'exit()': FunctionFragment;
    'getReward()': FunctionFragment;
    'kickValidatorInNextEpoch(address,uint256,bytes)': FunctionFragment;
    'lockValidatorsForNextEpoch()': FunctionFragment;
    'requestToJoin(uint32,uint128,uint32,address,uint256,uint256)': FunctionFragment;
    'requestToLeave()': FunctionFragment;
    'setConfig(uint256,uint256,uint256,uint256[],uint256)': FunctionFragment;
    'setContractResolver(address)': FunctionFragment;
    'setEpochEndTime(uint256)': FunctionFragment;
    'setEpochLength(uint256)': FunctionFragment;
    'setEpochState(uint8)': FunctionFragment;
    'setEpochTimeout(uint256)': FunctionFragment;
    'setIpPortNodeAddressAndCommunicationPubKeys(uint32,uint128,uint32,address,uint256,uint256)': FunctionFragment;
    'setKickPenaltyPercent(uint256,uint256)': FunctionFragment;
    'signalReadyForNextEpoch(uint256)': FunctionFragment;
    'stake(uint256)': FunctionFragment;
    'stakeAndJoin(uint256,uint32,uint128,uint32,address,uint256,uint256)': FunctionFragment;
    'unlockValidatorsForNextEpoch()': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
    'checkVersion((uint256,uint256,uint256))': FunctionFragment;
    'getMaxVersion()': FunctionFragment;
    'getMaxVersionString()': FunctionFragment;
    'getMinVersion()': FunctionFragment;
    'getMinVersionString()': FunctionFragment;
    'setMaxVersion((uint256,uint256,uint256))': FunctionFragment;
    'setMinVersion((uint256,uint256,uint256))': FunctionFragment;
    'config()': FunctionFragment;
    'contractResolver()': FunctionFragment;
    'countOfCurrentValidatorsReadyForNextEpoch()': FunctionFragment;
    'countOfNextValidatorsReadyForNextEpoch()': FunctionFragment;
    'currentValidatorCountForConsensus()': FunctionFragment;
    'epoch()': FunctionFragment;
    'getKeyTypes()': FunctionFragment;
    'getKickedValidators()': FunctionFragment;
    'getStakingBalancesAddress()': FunctionFragment;
    'getTokenAddress()': FunctionFragment;
    'getValidatorsInCurrentEpoch()': FunctionFragment;
    'getValidatorsInCurrentEpochLength()': FunctionFragment;
    'getValidatorsInNextEpoch()': FunctionFragment;
    'getValidatorsStructs(address[])': FunctionFragment;
    'getValidatorsStructsInCurrentEpoch()': FunctionFragment;
    'getValidatorsStructsInNextEpoch()': FunctionFragment;
    'getVotingStatusToKickValidator(uint256,address,address)': FunctionFragment;
    'isActiveValidator(address)': FunctionFragment;
    'isActiveValidatorByNodeAddress(address)': FunctionFragment;
    'isReadyForNextEpoch()': FunctionFragment;
    'kickPenaltyPercentByReason(uint256)': FunctionFragment;
    'nextValidatorCountForConsensus()': FunctionFragment;
    'nodeAddressToStakerAddress(address)': FunctionFragment;
    'readyForNextEpoch(address)': FunctionFragment;
    'shouldKickValidator(address)': FunctionFragment;
    'state()': FunctionFragment;
    'validators(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'diamondCut'
      | 'facetAddress'
      | 'facetAddresses'
      | 'facetFunctionSelectors'
      | 'facets'
      | 'supportsInterface'
      | 'owner'
      | 'transferOwnership'
      | 'adminKickValidatorInNextEpoch'
      | 'adminRejoinValidator'
      | 'adminSlashValidator'
      | 'advanceEpoch'
      | 'exit'
      | 'getReward'
      | 'kickValidatorInNextEpoch'
      | 'lockValidatorsForNextEpoch'
      | 'requestToJoin'
      | 'requestToLeave'
      | 'setConfig'
      | 'setContractResolver'
      | 'setEpochEndTime'
      | 'setEpochLength'
      | 'setEpochState'
      | 'setEpochTimeout'
      | 'setIpPortNodeAddressAndCommunicationPubKeys'
      | 'setKickPenaltyPercent'
      | 'signalReadyForNextEpoch'
      | 'stake'
      | 'stakeAndJoin'
      | 'unlockValidatorsForNextEpoch'
      | 'withdraw'
      | 'checkVersion'
      | 'getMaxVersion'
      | 'getMaxVersionString'
      | 'getMinVersion'
      | 'getMinVersionString'
      | 'setMaxVersion'
      | 'setMinVersion'
      | 'config'
      | 'contractResolver'
      | 'countOfCurrentValidatorsReadyForNextEpoch'
      | 'countOfNextValidatorsReadyForNextEpoch'
      | 'currentValidatorCountForConsensus'
      | 'epoch'
      | 'getKeyTypes'
      | 'getKickedValidators'
      | 'getStakingBalancesAddress'
      | 'getTokenAddress'
      | 'getValidatorsInCurrentEpoch'
      | 'getValidatorsInCurrentEpochLength'
      | 'getValidatorsInNextEpoch'
      | 'getValidatorsStructs'
      | 'getValidatorsStructsInCurrentEpoch'
      | 'getValidatorsStructsInNextEpoch'
      | 'getVotingStatusToKickValidator'
      | 'isActiveValidator'
      | 'isActiveValidatorByNodeAddress'
      | 'isReadyForNextEpoch'
      | 'kickPenaltyPercentByReason'
      | 'nextValidatorCountForConsensus'
      | 'nodeAddressToStakerAddress'
      | 'readyForNextEpoch'
      | 'shouldKickValidator'
      | 'state'
      | 'validators'
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'diamondCut',
    values: [IDiamond.FacetCutStruct[], string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'facetAddress',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'facetAddresses',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'facetFunctionSelectors',
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: 'facets', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'adminKickValidatorInNextEpoch',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'adminRejoinValidator',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'adminSlashValidator',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'advanceEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: 'exit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getReward', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'kickValidatorInNextEpoch',
    values: [string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'lockValidatorsForNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'requestToJoin',
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'requestToLeave',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'setConfig',
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish[],
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'setContractResolver',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEpochEndTime',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEpochLength',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEpochState',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEpochTimeout',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'setIpPortNodeAddressAndCommunicationPubKeys',
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'setKickPenaltyPercent',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'signalReadyForNextEpoch',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'stake', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'stakeAndJoin',
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'unlockValidatorsForNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'checkVersion',
    values: [LibStakingStorage.VersionStruct]
  ): string;
  encodeFunctionData(
    functionFragment: 'getMaxVersion',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getMaxVersionString',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getMinVersion',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getMinVersionString',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'setMaxVersion',
    values: [LibStakingStorage.VersionStruct]
  ): string;
  encodeFunctionData(
    functionFragment: 'setMinVersion',
    values: [LibStakingStorage.VersionStruct]
  ): string;
  encodeFunctionData(functionFragment: 'config', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'contractResolver',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'countOfCurrentValidatorsReadyForNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'countOfNextValidatorsReadyForNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'currentValidatorCountForConsensus',
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: 'epoch', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getKeyTypes',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getKickedValidators',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getStakingBalancesAddress',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getTokenAddress',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getValidatorsInCurrentEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getValidatorsInCurrentEpochLength',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getValidatorsInNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getValidatorsStructs',
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'getValidatorsStructsInCurrentEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getValidatorsStructsInNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getVotingStatusToKickValidator',
    values: [BigNumberish, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isActiveValidator',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isActiveValidatorByNodeAddress',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isReadyForNextEpoch',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'kickPenaltyPercentByReason',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'nextValidatorCountForConsensus',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'nodeAddressToStakerAddress',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'readyForNextEpoch',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'shouldKickValidator',
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: 'state', values?: undefined): string;
  encodeFunctionData(functionFragment: 'validators', values: [string]): string;

  decodeFunctionResult(functionFragment: 'diamondCut', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'facetAddress',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'facetAddresses',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'facetFunctionSelectors',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'facets', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'transferOwnership',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'adminKickValidatorInNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'adminRejoinValidator',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'adminSlashValidator',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'advanceEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'exit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'kickValidatorInNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'lockValidatorsForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'requestToJoin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'requestToLeave',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'setConfig', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'setContractResolver',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setEpochEndTime',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setEpochLength',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setEpochState',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setEpochTimeout',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setIpPortNodeAddressAndCommunicationPubKeys',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setKickPenaltyPercent',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'signalReadyForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'stake', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'stakeAndJoin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'unlockValidatorsForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'checkVersion',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getMaxVersion',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getMaxVersionString',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getMinVersion',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getMinVersionString',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setMaxVersion',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setMinVersion',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'config', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'contractResolver',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'countOfCurrentValidatorsReadyForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'countOfNextValidatorsReadyForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'currentValidatorCountForConsensus',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'epoch', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getKeyTypes',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getKickedValidators',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getStakingBalancesAddress',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getTokenAddress',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getValidatorsInCurrentEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getValidatorsInCurrentEpochLength',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getValidatorsInNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getValidatorsStructs',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getValidatorsStructsInCurrentEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getValidatorsStructsInNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getVotingStatusToKickValidator',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isActiveValidator',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isActiveValidatorByNodeAddress',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isReadyForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'kickPenaltyPercentByReason',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'nextValidatorCountForConsensus',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'nodeAddressToStakerAddress',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'readyForNextEpoch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'shouldKickValidator',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'state', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validators', data: BytesLike): Result;

  events: {
    'DiamondCut((address,uint8,bytes4[])[],address,bytes)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'ConfigSet(uint256,uint256,uint256,uint256[],uint256)': EventFragment;
    'EpochEndTimeSet(uint256)': EventFragment;
    'EpochLengthSet(uint256)': EventFragment;
    'EpochTimeoutSet(uint256)': EventFragment;
    'KickPenaltyPercentSet(uint256,uint256)': EventFragment;
    'ReadyForNextEpoch(address,uint256)': EventFragment;
    'Recovered(address,uint256)': EventFragment;
    'RequestToJoin(address)': EventFragment;
    'RequestToLeave(address)': EventFragment;
    'ResolverContractAddressSet(address)': EventFragment;
    'RewardsDurationUpdated(uint256)': EventFragment;
    'StakingTokenSet(address)': EventFragment;
    'StateChanged(uint8)': EventFragment;
    'ValidatorKickedFromNextEpoch(address,uint256)': EventFragment;
    'ValidatorRejoinedNextEpoch(address)': EventFragment;
    'VotedToKickValidatorInNextEpoch(address,address,uint256,bytes)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'DiamondCut'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ConfigSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EpochEndTimeSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EpochLengthSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EpochTimeoutSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'KickPenaltyPercentSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReadyForNextEpoch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Recovered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RequestToJoin'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RequestToLeave'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ResolverContractAddressSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsDurationUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StakingTokenSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StateChanged'): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: 'ValidatorKickedFromNextEpoch'
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ValidatorRejoinedNextEpoch'): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: 'VotedToKickValidatorInNextEpoch'
  ): EventFragment;
}

export interface DiamondCutEventObject {
  _diamondCut: IDiamond.FacetCutStructOutput[];
  _init: string;
  _calldata: string;
}
export type DiamondCutEvent = TypedEvent<
  [IDiamond.FacetCutStructOutput[], string, string],
  DiamondCutEventObject
>;

export type DiamondCutEventFilter = TypedEventFilter<DiamondCutEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ConfigSetEventObject {
  newTokenRewardPerTokenPerEpoch: BigNumber;
  newComplaintTolerance: BigNumber;
  newComplaintIntervalSecs: BigNumber;
  newKeyTypes: BigNumber[];
  newMinimumValidatorCount: BigNumber;
}
export type ConfigSetEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber[], BigNumber],
  ConfigSetEventObject
>;

export type ConfigSetEventFilter = TypedEventFilter<ConfigSetEvent>;

export interface EpochEndTimeSetEventObject {
  newEpochEndTime: BigNumber;
}
export type EpochEndTimeSetEvent = TypedEvent<
  [BigNumber],
  EpochEndTimeSetEventObject
>;

export type EpochEndTimeSetEventFilter = TypedEventFilter<EpochEndTimeSetEvent>;

export interface EpochLengthSetEventObject {
  newEpochLength: BigNumber;
}
export type EpochLengthSetEvent = TypedEvent<
  [BigNumber],
  EpochLengthSetEventObject
>;

export type EpochLengthSetEventFilter = TypedEventFilter<EpochLengthSetEvent>;

export interface EpochTimeoutSetEventObject {
  newEpochTimeout: BigNumber;
}
export type EpochTimeoutSetEvent = TypedEvent<
  [BigNumber],
  EpochTimeoutSetEventObject
>;

export type EpochTimeoutSetEventFilter = TypedEventFilter<EpochTimeoutSetEvent>;

export interface KickPenaltyPercentSetEventObject {
  reason: BigNumber;
  newKickPenaltyPercent: BigNumber;
}
export type KickPenaltyPercentSetEvent = TypedEvent<
  [BigNumber, BigNumber],
  KickPenaltyPercentSetEventObject
>;

export type KickPenaltyPercentSetEventFilter =
  TypedEventFilter<KickPenaltyPercentSetEvent>;

export interface ReadyForNextEpochEventObject {
  staker: string;
  epochNumber: BigNumber;
}
export type ReadyForNextEpochEvent = TypedEvent<
  [string, BigNumber],
  ReadyForNextEpochEventObject
>;

export type ReadyForNextEpochEventFilter =
  TypedEventFilter<ReadyForNextEpochEvent>;

export interface RecoveredEventObject {
  token: string;
  amount: BigNumber;
}
export type RecoveredEvent = TypedEvent<
  [string, BigNumber],
  RecoveredEventObject
>;

export type RecoveredEventFilter = TypedEventFilter<RecoveredEvent>;

export interface RequestToJoinEventObject {
  staker: string;
}
export type RequestToJoinEvent = TypedEvent<[string], RequestToJoinEventObject>;

export type RequestToJoinEventFilter = TypedEventFilter<RequestToJoinEvent>;

export interface RequestToLeaveEventObject {
  staker: string;
}
export type RequestToLeaveEvent = TypedEvent<
  [string],
  RequestToLeaveEventObject
>;

export type RequestToLeaveEventFilter = TypedEventFilter<RequestToLeaveEvent>;

export interface ResolverContractAddressSetEventObject {
  newResolverContractAddress: string;
}
export type ResolverContractAddressSetEvent = TypedEvent<
  [string],
  ResolverContractAddressSetEventObject
>;

export type ResolverContractAddressSetEventFilter =
  TypedEventFilter<ResolverContractAddressSetEvent>;

export interface RewardsDurationUpdatedEventObject {
  newDuration: BigNumber;
}
export type RewardsDurationUpdatedEvent = TypedEvent<
  [BigNumber],
  RewardsDurationUpdatedEventObject
>;

export type RewardsDurationUpdatedEventFilter =
  TypedEventFilter<RewardsDurationUpdatedEvent>;

export interface StakingTokenSetEventObject {
  newStakingTokenAddress: string;
}
export type StakingTokenSetEvent = TypedEvent<
  [string],
  StakingTokenSetEventObject
>;

export type StakingTokenSetEventFilter = TypedEventFilter<StakingTokenSetEvent>;

export interface StateChangedEventObject {
  newState: number;
}
export type StateChangedEvent = TypedEvent<[number], StateChangedEventObject>;

export type StateChangedEventFilter = TypedEventFilter<StateChangedEvent>;

export interface ValidatorKickedFromNextEpochEventObject {
  staker: string;
  amountBurned: BigNumber;
}
export type ValidatorKickedFromNextEpochEvent = TypedEvent<
  [string, BigNumber],
  ValidatorKickedFromNextEpochEventObject
>;

export type ValidatorKickedFromNextEpochEventFilter =
  TypedEventFilter<ValidatorKickedFromNextEpochEvent>;

export interface ValidatorRejoinedNextEpochEventObject {
  staker: string;
}
export type ValidatorRejoinedNextEpochEvent = TypedEvent<
  [string],
  ValidatorRejoinedNextEpochEventObject
>;

export type ValidatorRejoinedNextEpochEventFilter =
  TypedEventFilter<ValidatorRejoinedNextEpochEvent>;

export interface VotedToKickValidatorInNextEpochEventObject {
  reporter: string;
  validatorStakerAddress: string;
  reason: BigNumber;
  data: string;
}
export type VotedToKickValidatorInNextEpochEvent = TypedEvent<
  [string, string, BigNumber, string],
  VotedToKickValidatorInNextEpochEventObject
>;

export type VotedToKickValidatorInNextEpochEventFilter =
  TypedEventFilter<VotedToKickValidatorInNextEpochEvent>;

export interface Staking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: StakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    diamondCut(
      _diamondCut: IDiamond.FacetCutStruct[],
      _init: string,
      _calldata: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    facetAddress(
      _functionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { facetAddress_: string }>;

    facetAddresses(
      overrides?: CallOverrides
    ): Promise<[string[]] & { facetAddresses_: string[] }>;

    facetFunctionSelectors(
      _facet: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { _facetFunctionSelectors: string[] }>;

    facets(overrides?: CallOverrides): Promise<
      [IDiamondLoupe.FacetStructOutput[]] & {
        facets_: IDiamondLoupe.FacetStructOutput[];
      }
    >;

    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string] & { owner_: string }>;

    transferOwnership(
      _newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    adminKickValidatorInNextEpoch(
      validatorStakerAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    adminRejoinValidator(
      staker: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    adminSlashValidator(
      validatorStakerAddress: string,
      amountToPenalize: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    advanceEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    exit(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getReward(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    kickValidatorInNextEpoch(
      validatorStakerAddress: string,
      reason: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    lockValidatorsForNextEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    requestToJoin(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    requestToLeave(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setConfig(
      newTokenRewardPerTokenPerEpoch: BigNumberish,
      newComplaintTolerance: BigNumberish,
      newComplaintIntervalSecs: BigNumberish,
      newKeyTypes: BigNumberish[],
      newMinimumValidatorCount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setContractResolver(
      newResolverAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setEpochEndTime(
      newEpochEndTime: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setEpochLength(
      newEpochLength: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setEpochState(
      newState: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setEpochTimeout(
      newEpochTimeout: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setIpPortNodeAddressAndCommunicationPubKeys(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setKickPenaltyPercent(
      reason: BigNumberish,
      newKickPenaltyPercent: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    signalReadyForNextEpoch(
      epochNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    stake(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    stakeAndJoin(
      amount: BigNumberish,
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    unlockValidatorsForNextEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    checkVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getMaxVersion(
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.VersionStructOutput]>;

    getMaxVersionString(overrides?: CallOverrides): Promise<[string]>;

    getMinVersion(
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.VersionStructOutput]>;

    getMinVersionString(overrides?: CallOverrides): Promise<[string]>;

    setMaxVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setMinVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    config(
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.ConfigStructOutput]>;

    contractResolver(overrides?: CallOverrides): Promise<[string]>;

    countOfCurrentValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    countOfNextValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    currentValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    epoch(
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.EpochStructOutput]>;

    getKeyTypes(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    getKickedValidators(overrides?: CallOverrides): Promise<[string[]]>;

    getStakingBalancesAddress(overrides?: CallOverrides): Promise<[string]>;

    getTokenAddress(overrides?: CallOverrides): Promise<[string]>;

    getValidatorsInCurrentEpoch(overrides?: CallOverrides): Promise<[string[]]>;

    getValidatorsInCurrentEpochLength(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getValidatorsInNextEpoch(overrides?: CallOverrides): Promise<[string[]]>;

    getValidatorsStructs(
      addresses: string[],
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.ValidatorStructOutput[]]>;

    getValidatorsStructsInCurrentEpoch(
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.ValidatorStructOutput[]]>;

    getValidatorsStructsInNextEpoch(
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.ValidatorStructOutput[]]>;

    getVotingStatusToKickValidator(
      epochNumber: BigNumberish,
      validatorStakerAddress: string,
      voterStakerAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean]>;

    isActiveValidator(
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isActiveValidatorByNodeAddress(
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isReadyForNextEpoch(overrides?: CallOverrides): Promise<[boolean]>;

    kickPenaltyPercentByReason(
      reason: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nextValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nodeAddressToStakerAddress(
      nodeAddress: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    readyForNextEpoch(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    shouldKickValidator(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    state(overrides?: CallOverrides): Promise<[number]>;

    validators(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<[LibStakingStorage.ValidatorStructOutput]>;
  };

  diamondCut(
    _diamondCut: IDiamond.FacetCutStruct[],
    _init: string,
    _calldata: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  facetAddress(
    _functionSelector: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  facetAddresses(overrides?: CallOverrides): Promise<string[]>;

  facetFunctionSelectors(
    _facet: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  facets(overrides?: CallOverrides): Promise<IDiamondLoupe.FacetStructOutput[]>;

  supportsInterface(
    _interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    _newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  adminKickValidatorInNextEpoch(
    validatorStakerAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  adminRejoinValidator(
    staker: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  adminSlashValidator(
    validatorStakerAddress: string,
    amountToPenalize: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  advanceEpoch(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  exit(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  getReward(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  kickValidatorInNextEpoch(
    validatorStakerAddress: string,
    reason: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  lockValidatorsForNextEpoch(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  requestToJoin(
    ip: BigNumberish,
    ipv6: BigNumberish,
    port: BigNumberish,
    nodeAddress: string,
    senderPubKey: BigNumberish,
    receiverPubKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  requestToLeave(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setConfig(
    newTokenRewardPerTokenPerEpoch: BigNumberish,
    newComplaintTolerance: BigNumberish,
    newComplaintIntervalSecs: BigNumberish,
    newKeyTypes: BigNumberish[],
    newMinimumValidatorCount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setContractResolver(
    newResolverAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setEpochEndTime(
    newEpochEndTime: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setEpochLength(
    newEpochLength: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setEpochState(
    newState: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setEpochTimeout(
    newEpochTimeout: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setIpPortNodeAddressAndCommunicationPubKeys(
    ip: BigNumberish,
    ipv6: BigNumberish,
    port: BigNumberish,
    nodeAddress: string,
    senderPubKey: BigNumberish,
    receiverPubKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setKickPenaltyPercent(
    reason: BigNumberish,
    newKickPenaltyPercent: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  signalReadyForNextEpoch(
    epochNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  stake(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  stakeAndJoin(
    amount: BigNumberish,
    ip: BigNumberish,
    ipv6: BigNumberish,
    port: BigNumberish,
    nodeAddress: string,
    senderPubKey: BigNumberish,
    receiverPubKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  unlockValidatorsForNextEpoch(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  withdraw(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  checkVersion(
    version: LibStakingStorage.VersionStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getMaxVersion(
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.VersionStructOutput>;

  getMaxVersionString(overrides?: CallOverrides): Promise<string>;

  getMinVersion(
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.VersionStructOutput>;

  getMinVersionString(overrides?: CallOverrides): Promise<string>;

  setMaxVersion(
    version: LibStakingStorage.VersionStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setMinVersion(
    version: LibStakingStorage.VersionStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  config(
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.ConfigStructOutput>;

  contractResolver(overrides?: CallOverrides): Promise<string>;

  countOfCurrentValidatorsReadyForNextEpoch(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  countOfNextValidatorsReadyForNextEpoch(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  currentValidatorCountForConsensus(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  epoch(
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.EpochStructOutput>;

  getKeyTypes(overrides?: CallOverrides): Promise<BigNumber[]>;

  getKickedValidators(overrides?: CallOverrides): Promise<string[]>;

  getStakingBalancesAddress(overrides?: CallOverrides): Promise<string>;

  getTokenAddress(overrides?: CallOverrides): Promise<string>;

  getValidatorsInCurrentEpoch(overrides?: CallOverrides): Promise<string[]>;

  getValidatorsInCurrentEpochLength(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getValidatorsInNextEpoch(overrides?: CallOverrides): Promise<string[]>;

  getValidatorsStructs(
    addresses: string[],
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.ValidatorStructOutput[]>;

  getValidatorsStructsInCurrentEpoch(
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.ValidatorStructOutput[]>;

  getValidatorsStructsInNextEpoch(
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.ValidatorStructOutput[]>;

  getVotingStatusToKickValidator(
    epochNumber: BigNumberish,
    validatorStakerAddress: string,
    voterStakerAddress: string,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean]>;

  isActiveValidator(
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isActiveValidatorByNodeAddress(
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isReadyForNextEpoch(overrides?: CallOverrides): Promise<boolean>;

  kickPenaltyPercentByReason(
    reason: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nextValidatorCountForConsensus(overrides?: CallOverrides): Promise<BigNumber>;

  nodeAddressToStakerAddress(
    nodeAddress: string,
    overrides?: CallOverrides
  ): Promise<string>;

  readyForNextEpoch(
    stakerAddress: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  shouldKickValidator(
    stakerAddress: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  state(overrides?: CallOverrides): Promise<number>;

  validators(
    stakerAddress: string,
    overrides?: CallOverrides
  ): Promise<LibStakingStorage.ValidatorStructOutput>;

  callStatic: {
    diamondCut(
      _diamondCut: IDiamond.FacetCutStruct[],
      _init: string,
      _calldata: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    facetAddress(
      _functionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    facetAddresses(overrides?: CallOverrides): Promise<string[]>;

    facetFunctionSelectors(
      _facet: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    facets(
      overrides?: CallOverrides
    ): Promise<IDiamondLoupe.FacetStructOutput[]>;

    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      _newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    adminKickValidatorInNextEpoch(
      validatorStakerAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    adminRejoinValidator(
      staker: string,
      overrides?: CallOverrides
    ): Promise<void>;

    adminSlashValidator(
      validatorStakerAddress: string,
      amountToPenalize: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    advanceEpoch(overrides?: CallOverrides): Promise<void>;

    exit(overrides?: CallOverrides): Promise<void>;

    getReward(overrides?: CallOverrides): Promise<void>;

    kickValidatorInNextEpoch(
      validatorStakerAddress: string,
      reason: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    lockValidatorsForNextEpoch(overrides?: CallOverrides): Promise<void>;

    requestToJoin(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    requestToLeave(overrides?: CallOverrides): Promise<void>;

    setConfig(
      newTokenRewardPerTokenPerEpoch: BigNumberish,
      newComplaintTolerance: BigNumberish,
      newComplaintIntervalSecs: BigNumberish,
      newKeyTypes: BigNumberish[],
      newMinimumValidatorCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setContractResolver(
      newResolverAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setEpochEndTime(
      newEpochEndTime: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setEpochLength(
      newEpochLength: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setEpochState(
      newState: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setEpochTimeout(
      newEpochTimeout: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setIpPortNodeAddressAndCommunicationPubKeys(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setKickPenaltyPercent(
      reason: BigNumberish,
      newKickPenaltyPercent: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    signalReadyForNextEpoch(
      epochNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    stakeAndJoin(
      amount: BigNumberish,
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    unlockValidatorsForNextEpoch(overrides?: CallOverrides): Promise<void>;

    withdraw(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    checkVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getMaxVersion(
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.VersionStructOutput>;

    getMaxVersionString(overrides?: CallOverrides): Promise<string>;

    getMinVersion(
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.VersionStructOutput>;

    getMinVersionString(overrides?: CallOverrides): Promise<string>;

    setMaxVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    config(
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.ConfigStructOutput>;

    contractResolver(overrides?: CallOverrides): Promise<string>;

    countOfCurrentValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    countOfNextValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    currentValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    epoch(
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.EpochStructOutput>;

    getKeyTypes(overrides?: CallOverrides): Promise<BigNumber[]>;

    getKickedValidators(overrides?: CallOverrides): Promise<string[]>;

    getStakingBalancesAddress(overrides?: CallOverrides): Promise<string>;

    getTokenAddress(overrides?: CallOverrides): Promise<string>;

    getValidatorsInCurrentEpoch(overrides?: CallOverrides): Promise<string[]>;

    getValidatorsInCurrentEpochLength(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValidatorsInNextEpoch(overrides?: CallOverrides): Promise<string[]>;

    getValidatorsStructs(
      addresses: string[],
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.ValidatorStructOutput[]>;

    getValidatorsStructsInCurrentEpoch(
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.ValidatorStructOutput[]>;

    getValidatorsStructsInNextEpoch(
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.ValidatorStructOutput[]>;

    getVotingStatusToKickValidator(
      epochNumber: BigNumberish,
      validatorStakerAddress: string,
      voterStakerAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean]>;

    isActiveValidator(
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isActiveValidatorByNodeAddress(
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isReadyForNextEpoch(overrides?: CallOverrides): Promise<boolean>;

    kickPenaltyPercentByReason(
      reason: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nextValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nodeAddressToStakerAddress(
      nodeAddress: string,
      overrides?: CallOverrides
    ): Promise<string>;

    readyForNextEpoch(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    shouldKickValidator(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    state(overrides?: CallOverrides): Promise<number>;

    validators(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<LibStakingStorage.ValidatorStructOutput>;
  };

  filters: {
    'DiamondCut((address,uint8,bytes4[])[],address,bytes)'(
      _diamondCut?: null,
      _init?: null,
      _calldata?: null
    ): DiamondCutEventFilter;
    DiamondCut(
      _diamondCut?: null,
      _init?: null,
      _calldata?: null
    ): DiamondCutEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    'ConfigSet(uint256,uint256,uint256,uint256[],uint256)'(
      newTokenRewardPerTokenPerEpoch?: null,
      newComplaintTolerance?: null,
      newComplaintIntervalSecs?: null,
      newKeyTypes?: null,
      newMinimumValidatorCount?: null
    ): ConfigSetEventFilter;
    ConfigSet(
      newTokenRewardPerTokenPerEpoch?: null,
      newComplaintTolerance?: null,
      newComplaintIntervalSecs?: null,
      newKeyTypes?: null,
      newMinimumValidatorCount?: null
    ): ConfigSetEventFilter;

    'EpochEndTimeSet(uint256)'(
      newEpochEndTime?: null
    ): EpochEndTimeSetEventFilter;
    EpochEndTimeSet(newEpochEndTime?: null): EpochEndTimeSetEventFilter;

    'EpochLengthSet(uint256)'(newEpochLength?: null): EpochLengthSetEventFilter;
    EpochLengthSet(newEpochLength?: null): EpochLengthSetEventFilter;

    'EpochTimeoutSet(uint256)'(
      newEpochTimeout?: null
    ): EpochTimeoutSetEventFilter;
    EpochTimeoutSet(newEpochTimeout?: null): EpochTimeoutSetEventFilter;

    'KickPenaltyPercentSet(uint256,uint256)'(
      reason?: null,
      newKickPenaltyPercent?: null
    ): KickPenaltyPercentSetEventFilter;
    KickPenaltyPercentSet(
      reason?: null,
      newKickPenaltyPercent?: null
    ): KickPenaltyPercentSetEventFilter;

    'ReadyForNextEpoch(address,uint256)'(
      staker?: string | null,
      epochNumber?: null
    ): ReadyForNextEpochEventFilter;
    ReadyForNextEpoch(
      staker?: string | null,
      epochNumber?: null
    ): ReadyForNextEpochEventFilter;

    'Recovered(address,uint256)'(
      token?: null,
      amount?: null
    ): RecoveredEventFilter;
    Recovered(token?: null, amount?: null): RecoveredEventFilter;

    'RequestToJoin(address)'(staker?: string | null): RequestToJoinEventFilter;
    RequestToJoin(staker?: string | null): RequestToJoinEventFilter;

    'RequestToLeave(address)'(
      staker?: string | null
    ): RequestToLeaveEventFilter;
    RequestToLeave(staker?: string | null): RequestToLeaveEventFilter;

    'ResolverContractAddressSet(address)'(
      newResolverContractAddress?: null
    ): ResolverContractAddressSetEventFilter;
    ResolverContractAddressSet(
      newResolverContractAddress?: null
    ): ResolverContractAddressSetEventFilter;

    'RewardsDurationUpdated(uint256)'(
      newDuration?: null
    ): RewardsDurationUpdatedEventFilter;
    RewardsDurationUpdated(
      newDuration?: null
    ): RewardsDurationUpdatedEventFilter;

    'StakingTokenSet(address)'(
      newStakingTokenAddress?: null
    ): StakingTokenSetEventFilter;
    StakingTokenSet(newStakingTokenAddress?: null): StakingTokenSetEventFilter;

    'StateChanged(uint8)'(newState?: null): StateChangedEventFilter;
    StateChanged(newState?: null): StateChangedEventFilter;

    'ValidatorKickedFromNextEpoch(address,uint256)'(
      staker?: string | null,
      amountBurned?: null
    ): ValidatorKickedFromNextEpochEventFilter;
    ValidatorKickedFromNextEpoch(
      staker?: string | null,
      amountBurned?: null
    ): ValidatorKickedFromNextEpochEventFilter;

    'ValidatorRejoinedNextEpoch(address)'(
      staker?: null
    ): ValidatorRejoinedNextEpochEventFilter;
    ValidatorRejoinedNextEpoch(
      staker?: null
    ): ValidatorRejoinedNextEpochEventFilter;

    'VotedToKickValidatorInNextEpoch(address,address,uint256,bytes)'(
      reporter?: string | null,
      validatorStakerAddress?: string | null,
      reason?: BigNumberish | null,
      data?: null
    ): VotedToKickValidatorInNextEpochEventFilter;
    VotedToKickValidatorInNextEpoch(
      reporter?: string | null,
      validatorStakerAddress?: string | null,
      reason?: BigNumberish | null,
      data?: null
    ): VotedToKickValidatorInNextEpochEventFilter;
  };

  estimateGas: {
    diamondCut(
      _diamondCut: IDiamond.FacetCutStruct[],
      _init: string,
      _calldata: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    facetAddress(
      _functionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    facetAddresses(overrides?: CallOverrides): Promise<BigNumber>;

    facetFunctionSelectors(
      _facet: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    facets(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      _newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    adminKickValidatorInNextEpoch(
      validatorStakerAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    adminRejoinValidator(
      staker: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    adminSlashValidator(
      validatorStakerAddress: string,
      amountToPenalize: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    advanceEpoch(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    exit(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    getReward(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    kickValidatorInNextEpoch(
      validatorStakerAddress: string,
      reason: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    lockValidatorsForNextEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    requestToJoin(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    requestToLeave(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setConfig(
      newTokenRewardPerTokenPerEpoch: BigNumberish,
      newComplaintTolerance: BigNumberish,
      newComplaintIntervalSecs: BigNumberish,
      newKeyTypes: BigNumberish[],
      newMinimumValidatorCount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setContractResolver(
      newResolverAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setEpochEndTime(
      newEpochEndTime: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setEpochLength(
      newEpochLength: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setEpochState(
      newState: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setEpochTimeout(
      newEpochTimeout: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setIpPortNodeAddressAndCommunicationPubKeys(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setKickPenaltyPercent(
      reason: BigNumberish,
      newKickPenaltyPercent: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    signalReadyForNextEpoch(
      epochNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    stake(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    stakeAndJoin(
      amount: BigNumberish,
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    unlockValidatorsForNextEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    checkVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMaxVersion(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxVersionString(overrides?: CallOverrides): Promise<BigNumber>;

    getMinVersion(overrides?: CallOverrides): Promise<BigNumber>;

    getMinVersionString(overrides?: CallOverrides): Promise<BigNumber>;

    setMaxVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setMinVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    config(overrides?: CallOverrides): Promise<BigNumber>;

    contractResolver(overrides?: CallOverrides): Promise<BigNumber>;

    countOfCurrentValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    countOfNextValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    currentValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    epoch(overrides?: CallOverrides): Promise<BigNumber>;

    getKeyTypes(overrides?: CallOverrides): Promise<BigNumber>;

    getKickedValidators(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingBalancesAddress(overrides?: CallOverrides): Promise<BigNumber>;

    getTokenAddress(overrides?: CallOverrides): Promise<BigNumber>;

    getValidatorsInCurrentEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    getValidatorsInCurrentEpochLength(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValidatorsInNextEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    getValidatorsStructs(
      addresses: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValidatorsStructsInCurrentEpoch(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValidatorsStructsInNextEpoch(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVotingStatusToKickValidator(
      epochNumber: BigNumberish,
      validatorStakerAddress: string,
      voterStakerAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isActiveValidator(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isActiveValidatorByNodeAddress(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isReadyForNextEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    kickPenaltyPercentByReason(
      reason: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nextValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nodeAddressToStakerAddress(
      nodeAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    readyForNextEpoch(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    shouldKickValidator(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    state(overrides?: CallOverrides): Promise<BigNumber>;

    validators(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    diamondCut(
      _diamondCut: IDiamond.FacetCutStruct[],
      _init: string,
      _calldata: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    facetAddress(
      _functionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    facetAddresses(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    facetFunctionSelectors(
      _facet: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    facets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      _newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    adminKickValidatorInNextEpoch(
      validatorStakerAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    adminRejoinValidator(
      staker: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    adminSlashValidator(
      validatorStakerAddress: string,
      amountToPenalize: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    advanceEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    exit(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getReward(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    kickValidatorInNextEpoch(
      validatorStakerAddress: string,
      reason: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    lockValidatorsForNextEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    requestToJoin(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    requestToLeave(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setConfig(
      newTokenRewardPerTokenPerEpoch: BigNumberish,
      newComplaintTolerance: BigNumberish,
      newComplaintIntervalSecs: BigNumberish,
      newKeyTypes: BigNumberish[],
      newMinimumValidatorCount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setContractResolver(
      newResolverAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setEpochEndTime(
      newEpochEndTime: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setEpochLength(
      newEpochLength: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setEpochState(
      newState: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setEpochTimeout(
      newEpochTimeout: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setIpPortNodeAddressAndCommunicationPubKeys(
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setKickPenaltyPercent(
      reason: BigNumberish,
      newKickPenaltyPercent: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    signalReadyForNextEpoch(
      epochNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    stake(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    stakeAndJoin(
      amount: BigNumberish,
      ip: BigNumberish,
      ipv6: BigNumberish,
      port: BigNumberish,
      nodeAddress: string,
      senderPubKey: BigNumberish,
      receiverPubKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    unlockValidatorsForNextEpoch(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    checkVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMaxVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMaxVersionString(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMinVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMinVersionString(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setMaxVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setMinVersion(
      version: LibStakingStorage.VersionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    config(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    contractResolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    countOfCurrentValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    countOfNextValidatorsReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    currentValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    epoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getKeyTypes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getKickedValidators(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStakingBalancesAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getValidatorsInCurrentEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValidatorsInCurrentEpochLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValidatorsInNextEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValidatorsStructs(
      addresses: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValidatorsStructsInCurrentEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValidatorsStructsInNextEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVotingStatusToKickValidator(
      epochNumber: BigNumberish,
      validatorStakerAddress: string,
      voterStakerAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isActiveValidator(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isActiveValidatorByNodeAddress(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isReadyForNextEpoch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    kickPenaltyPercentByReason(
      reason: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nextValidatorCountForConsensus(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nodeAddressToStakerAddress(
      nodeAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    readyForNextEpoch(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    shouldKickValidator(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validators(
      stakerAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
